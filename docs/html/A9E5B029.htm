<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>IndexPartition Class</title><meta name="Title" content="IndexPartition" /><meta name="Help.Id" content="T:Novacta.Analytics.IndexPartition" /><meta name="Help.ContentType" content="Reference" /><meta name="container" content="Novacta.Analytics" /><meta name="guid" content="A9E5B029" /><meta name="Description" content="Provides static methods for creating index partition objects and for their evaluation in terms of linkage among parts." /><meta name="tocFile" content="../toc/IDAE.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div class="level-item"><img src="../icons/Help.png" /></div><div id="DocumentationTitle" class="level-item">Novacta.Analytics Documentation</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a><a class="dropdown-item languageFilterItem" data-languageId="vb">VB</a><a class="dropdown-item languageFilterItem" data-languageId="cpp">C++</a><a class="dropdown-item languageFilterItem" data-languageId="fs">F#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>Index<wbr />Partition Class</h1><div class="summary">
             Provides static methods for creating index partition objects and for their
             evaluation in terms of linkage among parts.
             </div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Definition</h2><div id="IDBSection"><strong>Namespace:</strong> <a href="2406EB43.htm">Novacta.Analytics</a><br /><strong>Assembly:</strong> Novacta.Analytics (in Novacta.Analytics.dll) Version: 2.1.0+428f3840cfab98dda567bb0ed350b302533e273a<div class="codeSnippet" data-codeSnippetLanguage="cs"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="identifier">IndexPartition</span></code></pre></div></div><div class="codeSnippet is-hidden" data-codeSnippetLanguage="vb"><div class="codeHeader"><span class="codeHeaderTitle">VB</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-vb"><span class="keyword">Public</span> <span class="keyword">NotInheritable</span> <span class="keyword">Class</span> <span class="identifier">IndexPartition</span></code></pre></div></div><div class="codeSnippet is-hidden" data-codeSnippetLanguage="cpp"><div class="codeHeader"><span class="codeHeaderTitle">C++</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cpp"><span class="keyword">public</span> <span class="keyword">ref class</span> <span class="identifier">IndexPartition</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span></code></pre></div></div><div class="codeSnippet is-hidden" data-codeSnippetLanguage="fs"><div class="codeHeader"><span class="codeHeaderTitle">F#</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-fs">[&lt;<span class="identifier">AbstractClassAttribute</span>&gt;]
[&lt;<span class="identifier">SealedAttribute</span>&gt;]
<span class="keyword">type</span> <span class="identifier">IndexPartition</span> = <span class="keyword">class</span> <span class="keyword">end</span></code></pre></div></div><dl class="inheritanceHierarchy"><dt>Inheritance</dt><dd><a href="https://learn.microsoft.com/dotnet/api/system.object" target="_blank" rel="noopener noreferrer">Object</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <span class="selflink">IndexPartition</span></dd></dl></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Remarks</h2><div id="IDBCSection"><p>
             An index partition is a data structure that has a specific number of
             parts. Each part is a collection of zero-based indexes represented by 
             an instance of type <a href="9B3BDFD7.htm">IndexCollection</a>,
             and has an 
             identifier whose type is a generic parameter. 
             In its general form, an index partition can be constructed on the base
             of an <a href="9B3BDFD7.htm">IndexCollection</a> instance: each index in the collection
             is passed to a <a href="https://learn.microsoft.com/dotnet/api/system.func-2" target="_blank" rel="noopener noreferrer">Func<span id="LSTA9E5B029_0" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T, TResult<span id="LSTA9E5B029_1" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a> object, which returns a
             value of type &lt;T&gt;, so that the indexes for which is returned the same
             value are inserted in the same part having such value as its identifier.
             This is the way an index partition is built by method
             <a href="10E1B5B6.htm">Create<span id="LSTA9E5B029_2" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>T<span id="LSTA9E5B029_3" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>(IndexCollection, Func<span id="LSTA9E5B029_4" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>Int32, T<span id="LSTA9E5B029_5" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>)</a>.
             However, an index partition is often initialized by inspecting a collection of 
             elements and adding a new part to the partition each time a new element is 
             encountered while iterating over the collection. 
             Such element is the identifier of the new part, which will store
             the positions, in the
             collection of elements, where reside values equal to the part identifier.
             As a consequence, the parts are mutually exclusive subsets of the 
             range of available collection positions.
             </p><p><b>Instantiation of IndexPartition&lt;T&gt; objects</b></p><p>
             The <span class="selflink">IndexPartition</span> class does not itself represent a partition. 
             Instead, it is 
             a class that provides the static method 
             <a href="8921C32.htm">Create<span id="LSTA9E5B029_6" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>T<span id="LSTA9E5B029_7" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>(IEnumerable<span id="LSTA9E5B029_8" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>T<span id="LSTA9E5B029_9" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>)</a>
             for creating instances of the 
             <a href="9A92A82.htm">IndexPartition<span id="LSTA9E5B029_10" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T<span id="LSTA9E5B029_11" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a> generic type.
             It also provides 
             method
             <a href="14EF3EF8.htm">Create(DoubleMatrix)</a>
             and its overloaded versions 
             that you can 
             call to instantiate partition objects 
             without having to explicitly specify the type of part identifiers
             when the type is <a href="https://learn.microsoft.com/dotnet/api/system.double" target="_blank" rel="noopener noreferrer">Double</a> or
             <a href="8C5BBFE.htm">DoubleMatrixRow</a>.
             </p><p><b>Partition evaluations</b></p><p>
             In Cluster Analysis, data collecting individual observations 
             of multiple variables are partitioned in clusters trying to 
             minimize the dissimilarity among clusters, or to maximize the 
             similarity of the individuals in each cluster. 
             To obtain such optimizations, a linkage between two given parts 
             can be defined in terms of the pairwise distances of their observations,
             and linkage criterions can be applied to evaluate different partitions
             in the search for the optimal one. Some criterions are exposed in
             class <span class="selflink">IndexPartition</span> as methods 
             <a href="1525DAE7.htm">MinimumMeanLinkage</a>,
             <a href="7F733272.htm">DunnIndex</a>, and
             <a href="40CF1518.htm">DaviesBouldinIndex</a>.
             </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Example</h2><div id="IDCCSection"><p>
             In the following example, the row indexes of a matrix are partitioned 
             by the contents of its first column.
             Each part is identified by a value, the part identifier, and contains
             the indexes of the rows in which the identifier 
             is positioned in the first column.
            </p><p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Partitioning the rows of a matrix by the contents of one of its columns</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">using System;

namespace Novacta.Analytics.CodeExamples
{
    public class IndexPartitionExample0  
    {
        public void Main()
        {
            // Create a matrix.
            var data = new double[18] {
                0,0,1,
                0,0,1,
                0,1,0,
                0,1,0,
                1,0,0,
                1,0,0
            }; 
            var matrix = DoubleMatrix.Dense(6, 3, data, StorageOrder.RowMajor);

            // Partition the matrix row indexes by the contents of column 0:
            // a part is created for each distinct value in column 0.
            var partition = IndexPartition.Create(matrix[":", 0]);

            // Each part is identified by its corresponding value and contains
            // the indexes of the rows in which the identifier
            // is positioned in column 0.
            Console.WriteLine();
            foreach (var identifier in partition.Identifiers) {
                Console.WriteLine("Part identifier: {0}", identifier);
                Console.WriteLine("     indexes: {0}", partition[identifier]);
                Console.WriteLine();
            }
        }
    }
}

// Executing method Main() produces the following output:
// 
// 
// Part identifier: 0
//      indexes: 0, 1, 2, 3
// 
// Part identifier: 1
//      indexes: 4, 5
//</code></pre></div></div></p><p> 
             In the following example, the row indexes of a matrix are partitioned 
             by the contents of its rows.
             Each part is identified by a distinct row, the part identifier, and contains
             the indexes of the rows which are equal to the identifier.
             </p><p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Partitioning the rows of a matrix by their contents</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">using System;

namespace Novacta.Analytics.CodeExamples
{
    public class IndexPartitionExample1  
    {
        public void Main()
        {
            // Create a matrix.
            var data = new double[18] {
                0,0,1,
                0,0,1,
                0,1,0,
                0,1,0,
                1,0,0,
                1,0,0
            };
            var matrix = DoubleMatrix.Dense(6, 3, data, StorageOrder.RowMajor);

            // Partition the matrix row indexes by the contents of each row:
            // a part is created for each distinct row.
            var partition = IndexPartition.Create(matrix.AsRowCollection());

            // Each part is identified by its corresponding row and contains
            // the indexes of the rows which are equal to the identifier.
            Console.WriteLine();
            foreach (var identifier in partition.Identifiers) {
                Console.WriteLine("Part identifier: {0}", identifier);
                Console.WriteLine("     indexes: {0}", partition[identifier]);
                Console.WriteLine();
            }
        }
    }
}

// Executing method Main() produces the following output:
// 
// 
// Part identifier: 0                0                1                
//      indexes: 0, 1
// 
// Part identifier: 0                1                0                
//      indexes: 2, 3
// 
// Part identifier: 1                0                0                
//      indexes: 4, 5
//</code></pre></div></div></p><p>
             In the following example, the linear indexes of a matrix are partitioned 
             by the sign of its entries.
             The part corresponding to zero entries is identified by zero, 
             the part corresponding to positive entries by 1, and the part of negative
             entries by -1.
             </p><p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Partitioning the linear indexes of a matrix by the sign of its entries</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">using System;

namespace Novacta.Analytics.CodeExamples
{
    public class IndexPartitionExample2  
    {
        public void Main()
        {
            // Create a matrix.
            var data = new double[8] {
                0, 1,-2,-3,
                0,-1, 2, 3
            };
            var matrix = DoubleMatrix.Dense(2, 4, data, StorageOrder.RowMajor);

            // Check the sign of its entries.
            var signs = DoubleMatrix.Dense(matrix.NumberOfRows, matrix.NumberOfColumns);
            for (int i = 0; i &lt; matrix.Count; i++) {
                signs[i] = Math.Sign(matrix[i]);
            }

            // Partition the matrix linear indexes by the sign of each entry.
            var partition = IndexPartition.Create(signs);

            // The partition contains three parts, the zero part, identified by 0,
            // the negative part (identified by -1), and the positive one 
            // (identified by 1).
            Console.WriteLine();
            foreach (var identifier in partition.Identifiers) {
                Console.WriteLine("Part identifier: {0}", identifier);
                Console.WriteLine("     indexes: {0}", partition[identifier]);
                Console.WriteLine();
            }
        }
    }
}

// Executing method Main() produces the following output:
// 
// 
// Part identifier: -1
//      indexes: 3, 4, 6
// 
// Part identifier: 0
//      indexes: 0, 1
// 
// Part identifier: 1
//      indexes: 2, 5, 7
//</code></pre></div></div></p><p> 
             In the following example, the indexes of an array of strings are partitioned 
             by their contents.
             </p><p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Partitioning the indexes of an array by its contents</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">using System;

namespace Novacta.Analytics.CodeExamples
{
    public class IndexPartitionExample3  
    {
        public void Main()
        {
            // Create an array of strings.
            var data = new string[6] {
                "one",
                "two",
                "one",
                "one",
                "three",
                "three"
            };

            // Partition the array positions by their contents.
            var partition = IndexPartition.Create(data);

            // The partition contains three parts, identified, respectively,
            // by the strings "one", "two", and "three".
            Console.WriteLine();
            foreach (var identifier in partition.Identifiers) {
                Console.WriteLine("Part identifier: {0}", identifier);
                Console.WriteLine("     indexes: {0}", partition[identifier]);
                Console.WriteLine();
            }
        }
    }
}

// Executing method Main() produces the following output:
// 
// 
// Part identifier: one
//      indexes: 0, 2, 3
// 
// Part identifier: three
//      indexes: 4, 5
// 
// Part identifier: two
//      indexes: 1
//</code></pre></div></div></p><p>
             In the following example, the linear indexes of the main diagonal of
             a matrix are partitioned 
             by checking if their corresponding entries are less than 3 in absolute
             value.
             Two parts are created, one for diagonal
             entries less than 3 in absolute value, the other for 
             entries not satisfying that condition.
             </p><p><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">Partitioning the main diagonal entries of a matrix by their absolute value satisfying a certain condition</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">using System;

namespace Novacta.Analytics.CodeExamples
{
    public class IndexPartitionExample5  
    {
        public void Main()
        {
            // Create a matrix.
            var data = new double[16] {
               -3,  3,  3, -1,
                0,  2, -2,  2,
                2,  1, -4, -5,  
               -8,  2,  7, -1
            };
            var matrix = DoubleMatrix.Dense(4, 4, data, StorageOrder.RowMajor);

            // Create the collection of linear indexes corresponding
            // to entries on the matrix main diagonal.
            var diagonalIndexes = 
                IndexCollection.Sequence(0, 1 + matrix.NumberOfRows, matrix.Count);

            // Create a partitioner which returns true if
            // the absolute value in a entry having the specified linear
            // index is less than 3, otherwise false.
            bool partitioner(int linearIndex)
            {
                return Math.Abs(matrix[linearIndex]) &lt; 3.0;
            }

            // Partition the diagonal linear indexes through the
            // specified partitioner.
            var partition = IndexPartition.Create(diagonalIndexes, partitioner);

            // Two parts are created, one for diagonal
            // entries less than 3 in absolute value, the other for 
            // entries not satisfying that condition.
            Console.WriteLine();
            foreach (var identifier in partition.Identifiers) {
                Console.WriteLine("Part identifier: {0}", identifier);
                Console.WriteLine("     indexes: {0}", partition[identifier]);
                Console.WriteLine();
            }
        }
    }
}

// Executing method Main() produces the following output:
// 
// 
// Part identifier: False
//      indexes: 0, 10
// 
// Part identifier: True
//      indexes: 5, 15
//</code></pre></div></div></p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Methods</h2><div id="IDBEASection"><table id="MethodList" class="table is-hoverable"><tr><td><a href="14EF3EF8.htm">Create(DoubleMatrix)</a></td><td>
            Creates a partition of positions in a collection of 
            <a href="https://learn.microsoft.com/dotnet/api/system.double" target="_blank" rel="noopener noreferrer">Double</a> elements by 
            aggregating those positions occupied by a same element.
            </td></tr><tr><td><a href="6EC1D0AB.htm">Create(DoubleMatrixRowCollection)</a></td><td>
            Creates a partition of positions in a collection of 
            <a href="8C5BBFE.htm">DoubleMatrixRow</a> 
            elements by 
            aggregating those positions occupied by a same element.
            </td></tr><tr><td><a href="8921C32.htm">Create<span id="LSTA9E5B029_12" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>T<span id="LSTA9E5B029_13" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>(IEnumerable<span id="LSTA9E5B029_14" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>T<span id="LSTA9E5B029_15" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>)</a></td><td>
            Creates a partition of positions in a collection of elements by 
            aggregating those positions occupied by a same element.
            </td></tr><tr><td><a href="10E1B5B6.htm">Create<span id="LSTA9E5B029_16" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>T<span id="LSTA9E5B029_17" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>(IndexCollection, Func<span id="LSTA9E5B029_18" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=("></span>Int32, T<span id="LSTA9E5B029_19" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)"></span>)</a></td><td>
            Creates a partition of the elements in 
            an <a href="9B3BDFD7.htm">IndexCollection</a> instance by 
            aggregating those elements corresponding to a same part.
            </td></tr><tr><td><a href="40CF1518.htm">DaviesBouldinIndex</a></td><td>
            Computes the Davies-Bouldin index to assess the quality of a given partition
            of the specified data.
            </td></tr><tr><td><a href="7F733272.htm">DunnIndex</a></td><td>
             Computes the Dunn index to assess the quality of a given partition
             of the specified data.
             </td></tr><tr><td><a href="1525DAE7.htm">MinimumCentroidLinkage</a></td><td>
            Computes the minimum centroid linkage among parts
            in the given partition of the specified data.
            </td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Reference</h4><div><a href="2406EB43.htm">Novacta.Analytics Namespace</a></div><div><a href="9A92A82.htm">IndexPartition<span id="LSTA9E5B029_20" data-languageSpecificText="cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'"></span>T<span id="LSTA9E5B029_21" data-languageSpecificText="cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;"></span></a></div><div><a href="2EBDA23.htm">Distance</a></div><div><a href="8C5BBFE.htm">DoubleMatrixRow</a></div><div><a href="F15A23E2.htm">Clusters</a></div><div><a href="240B10D.htm">PartitionOptimizationContext</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Definition</a></li><li><a class="quickLink">Remarks</a></li><li><a class="quickLink">Example</a></li><li><a class="quickLink">Methods</a></li><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div id="FooterContent" class="column"><p>Copyright (c) Giovanni Lafratta.</p> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>